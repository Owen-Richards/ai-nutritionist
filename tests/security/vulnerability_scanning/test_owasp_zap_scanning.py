"""
OWASP ZAP Security Scanner Integration Tests

This module provides comprehensive web application security testing using OWASP ZAP.
Tests include automated scanning for common vulnerabilities, API security testing,
and custom security rule validation.
"""

import os
import json
import time
import requests
import subprocess
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path
import pytest
from unittest.mock import Mock, patch

# ZAP Python API client
try:
    from zapv2 import ZAPv2
    ZAP_AVAILABLE = True
except ImportError:
    ZAP_AVAILABLE = False
    ZAPv2 = None


class OWASPZAPScanner:
    """OWASP ZAP security scanner integration."""
    
    def __init__(self, proxy_port: int = 8080, api_key: Optional[str] = None):
        self.proxy_port = proxy_port
        self.api_key = api_key or "test-api-key"
        self.zap = None
        self.results_dir = Path("tests/security/reports/zap")
        self.results_dir.mkdir(parents=True, exist_ok=True)
        
    def start_zap_daemon(self) -> bool:
        """Start ZAP daemon in headless mode."""
        try:
            # Check if ZAP is already running
            if self.is_zap_running():
                return True
                
            # Start ZAP daemon
            zap_cmd = [
                "zap.sh",  # or "zap.bat" on Windows
                "-daemon",
                "-port", str(self.proxy_port),
                "-config", f"api.key={self.api_key}",
                "-config", "api.addrs.addr.name=.*",
                "-config", "api.addrs.addr.regex=true"
            ]
            
            subprocess.Popen(zap_cmd)
            
            # Wait for ZAP to start
            for _ in range(30):
                if self.is_zap_running():
                    self.zap = ZAPv2(proxies={
                        'http': f'http://127.0.0.1:{self.proxy_port}',
                        'https': f'http://127.0.0.1:{self.proxy_port}'
                    }, apikey=self.api_key)
                    return True
                time.sleep(2)
                
            return False
            
        except Exception as e:
            print(f"Failed to start ZAP daemon: {e}")
            return False
    
    def is_zap_running(self) -> bool:
        """Check if ZAP daemon is running."""
        try:
            response = requests.get(
                f"http://127.0.0.1:{self.proxy_port}/JSON/core/view/version/",
                params={"apikey": self.api_key},
                timeout=5
            )
            return response.status_code == 200
        except:
            return False
    
    def passive_scan(self, target_url: str) -> Dict[str, Any]:
        """Perform passive security scan."""
        if not self.zap:
            raise RuntimeError("ZAP not initialized")
            
        # Access the target URL to populate ZAP's history
        self.zap.urlopen(target_url)
        
        # Wait for passive scan to complete
        while int(self.zap.pscan.records_to_scan) > 0:
            time.sleep(1)
            
        # Get passive scan results
        alerts = self.zap.core.alerts()
        
        return {
            "scan_type": "passive",
            "target_url": target_url,
            "timestamp": datetime.utcnow().isoformat(),
            "alerts": alerts,
            "alert_count": len(alerts),
            "high_risk_count": len([a for a in alerts if a['risk'] == 'High']),
            "medium_risk_count": len([a for a in alerts if a['risk'] == 'Medium']),
            "low_risk_count": len([a for a in alerts if a['risk'] == 'Low']),
            "info_count": len([a for a in alerts if a['risk'] == 'Informational'])
        }
    
    def active_scan(self, target_url: str) -> Dict[str, Any]:
        """Perform active security scan."""
        if not self.zap:
            raise RuntimeError("ZAP not initialized")
            
        # Start active scan
        scan_id = self.zap.ascan.scan(target_url)
        
        # Wait for scan to complete
        while int(self.zap.ascan.status(scan_id)) < 100:
            time.sleep(5)
            print(f"Active scan progress: {self.zap.ascan.status(scan_id)}%")
            
        # Get active scan results
        alerts = self.zap.core.alerts()
        
        return {
            "scan_type": "active",
            "target_url": target_url,
            "scan_id": scan_id,
            "timestamp": datetime.utcnow().isoformat(),
            "alerts": alerts,
            "alert_count": len(alerts),
            "high_risk_count": len([a for a in alerts if a['risk'] == 'High']),
            "medium_risk_count": len([a for a in alerts if a['risk'] == 'Medium']),
            "low_risk_count": len([a for a in alerts if a['risk'] == 'Low']),
            "info_count": len([a for a in alerts if a['risk'] == 'Informational'])
        }
    
    def api_scan(self, api_spec_url: str) -> Dict[str, Any]:
        """Perform API security scan using OpenAPI specification."""
        if not self.zap:
            raise RuntimeError("ZAP not initialized")
            
        try:
            # Import OpenAPI specification
            self.zap.openapi.import_url(api_spec_url)
            
            # Start active scan on API endpoints
            scan_id = self.zap.ascan.scan_as_user(
                url=api_spec_url,
                recurse=True
            )
            
            # Wait for scan completion
            while int(self.zap.ascan.status(scan_id)) < 100:
                time.sleep(5)
                
            alerts = self.zap.core.alerts()
            
            return {
                "scan_type": "api",
                "api_spec_url": api_spec_url,
                "scan_id": scan_id,
                "timestamp": datetime.utcnow().isoformat(),
                "alerts": alerts,
                "alert_count": len(alerts),
                "api_specific_issues": self._analyze_api_issues(alerts)
            }
            
        except Exception as e:
            return {
                "scan_type": "api",
                "api_spec_url": api_spec_url,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    def _analyze_api_issues(self, alerts: List[Dict]) -> Dict[str, List]:
        """Analyze API-specific security issues."""
        api_issues = {
            "authentication_bypass": [],
            "authorization_issues": [],
            "input_validation": [],
            "rate_limiting": [],
            "data_exposure": []
        }
        
        for alert in alerts:
            name = alert.get('name', '').lower()
            description = alert.get('description', '').lower()
            
            if any(term in name or term in description for term in 
                   ['auth', 'login', 'token', 'session']):
                if 'bypass' in name or 'bypass' in description:
                    api_issues["authentication_bypass"].append(alert)
                else:
                    api_issues["authorization_issues"].append(alert)
                    
            elif any(term in name or term in description for term in 
                     ['injection', 'xss', 'validation', 'input']):
                api_issues["input_validation"].append(alert)
                
            elif any(term in name or term in description for term in 
                     ['rate', 'limit', 'throttle', 'dos']):
                api_issues["rate_limiting"].append(alert)
                
            elif any(term in name or term in description for term in 
                     ['exposure', 'leak', 'disclosure', 'sensitive']):
                api_issues["data_exposure"].append(alert)
                
        return api_issues
    
    def generate_report(self, scan_results: Dict[str, Any], format: str = "json") -> str:
        """Generate security scan report."""
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"zap_scan_{scan_results['scan_type']}_{timestamp}.{format}"
        filepath = self.results_dir / filename
        
        if format == "json":
            with open(filepath, 'w') as f:
                json.dump(scan_results, f, indent=2)
        elif format == "html":
            html_report = self._generate_html_report(scan_results)
            with open(filepath, 'w') as f:
                f.write(html_report)
                
        return str(filepath)
    
    def _generate_html_report(self, results: Dict[str, Any]) -> str:
        """Generate HTML security report."""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>OWASP ZAP Security Scan Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f4f4f4; padding: 20px; border-radius: 5px; }}
                .alert {{ margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .high {{ background-color: #ffebee; border-left: 5px solid #f44336; }}
                .medium {{ background-color: #fff3e0; border-left: 5px solid #ff9800; }}
                .low {{ background-color: #f3e5f5; border-left: 5px solid #9c27b0; }}
                .info {{ background-color: #e8f5e8; border-left: 5px solid #4caf50; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>OWASP ZAP Security Scan Report</h1>
                <p><strong>Scan Type:</strong> {results['scan_type']}</p>
                <p><strong>Target:</strong> {results.get('target_url', 'N/A')}</p>
                <p><strong>Timestamp:</strong> {results['timestamp']}</p>
                <p><strong>Total Alerts:</strong> {results['alert_count']}</p>
            </div>
            
            <h2>Summary</h2>
            <ul>
                <li>High Risk: {results.get('high_risk_count', 0)}</li>
                <li>Medium Risk: {results.get('medium_risk_count', 0)}</li>
                <li>Low Risk: {results.get('low_risk_count', 0)}</li>
                <li>Informational: {results.get('info_count', 0)}</li>
            </ul>
        """
        
        if 'alerts' in results:
            html += "<h2>Detailed Alerts</h2>"
            for alert in results['alerts']:
                risk_class = alert.get('risk', 'info').lower()
                html += f"""
                <div class="alert {risk_class}">
                    <h3>{alert.get('name', 'Unknown Alert')}</h3>
                    <p><strong>Risk:</strong> {alert.get('risk', 'Unknown')}</p>
                    <p><strong>Confidence:</strong> {alert.get('confidence', 'Unknown')}</p>
                    <p><strong>Description:</strong> {alert.get('description', 'No description')}</p>
                    <p><strong>Solution:</strong> {alert.get('solution', 'No solution provided')}</p>
                </div>
                """
        
        html += "</body></html>"
        return html
    
    def shutdown(self):
        """Shutdown ZAP daemon."""
        if self.zap:
            try:
                self.zap.core.shutdown()
            except:
                pass


# Test Classes
@pytest.mark.skipif(not ZAP_AVAILABLE, reason="OWASP ZAP not available")
class TestOWASPZAPScanning:
    """OWASP ZAP security scanning tests."""
    
    @pytest.fixture(scope="class")
    def zap_scanner(self):
        """ZAP scanner fixture."""
        scanner = OWASPZAPScanner()
        if not scanner.start_zap_daemon():
            pytest.skip("Could not start ZAP daemon")
        yield scanner
        scanner.shutdown()
    
    def test_passive_scan(self, zap_scanner):
        """Test passive security scan."""
        target_url = "http://localhost:8000"  # Adjust for your API
        
        results = zap_scanner.passive_scan(target_url)
        
        assert results["scan_type"] == "passive"
        assert results["target_url"] == target_url
        assert "alerts" in results
        assert "alert_count" in results
        
        # Generate report
        report_path = zap_scanner.generate_report(results)
        assert Path(report_path).exists()
        
        # Analyze results
        high_risk_alerts = [a for a in results["alerts"] if a["risk"] == "High"]
        if high_risk_alerts:
            pytest.fail(f"High risk vulnerabilities found: {len(high_risk_alerts)}")
    
    def test_active_scan(self, zap_scanner):
        """Test active security scan."""
        target_url = "http://localhost:8000"
        
        results = zap_scanner.active_scan(target_url)
        
        assert results["scan_type"] == "active"
        assert results["target_url"] == target_url
        assert "scan_id" in results
        
        # Generate report
        report_path = zap_scanner.generate_report(results, "html")
        assert Path(report_path).exists()
        
        # Check for critical vulnerabilities
        critical_issues = [
            a for a in results["alerts"] 
            if a["risk"] == "High" and a["confidence"] in ["High", "Medium"]
        ]
        
        if critical_issues:
            print(f"WARNING: {len(critical_issues)} critical vulnerabilities found")
    
    def test_api_security_scan(self, zap_scanner):
        """Test API-specific security scan."""
        api_spec_url = "http://localhost:8000/openapi.json"
        
        results = zap_scanner.api_scan(api_spec_url)
        
        assert results["scan_type"] == "api"
        
        if "error" not in results:
            assert "api_specific_issues" in results
            
            # Check for common API vulnerabilities
            api_issues = results["api_specific_issues"]
            
            if api_issues["authentication_bypass"]:
                pytest.fail(f"Authentication bypass vulnerabilities: {len(api_issues['authentication_bypass'])}")
                
            if api_issues["authorization_issues"]:
                print(f"WARNING: Authorization issues found: {len(api_issues['authorization_issues'])}")
                
            if api_issues["data_exposure"]:
                print(f"WARNING: Data exposure issues found: {len(api_issues['data_exposure'])}")


class MockZAPScanner:
    """Mock ZAP scanner for testing without actual ZAP installation."""
    
    def __init__(self):
        self.results_dir = Path("tests/security/reports/zap")
        self.results_dir.mkdir(parents=True, exist_ok=True)
    
    def passive_scan(self, target_url: str) -> Dict[str, Any]:
        """Mock passive scan."""
        return {
            "scan_type": "passive",
            "target_url": target_url,
            "timestamp": datetime.utcnow().isoformat(),
            "alerts": [
                {
                    "name": "Missing Security Headers",
                    "risk": "Medium",
                    "confidence": "High",
                    "description": "Security headers not implemented",
                    "solution": "Implement security headers middleware"
                }
            ],
            "alert_count": 1,
            "high_risk_count": 0,
            "medium_risk_count": 1,
            "low_risk_count": 0,
            "info_count": 0
        }
    
    def active_scan(self, target_url: str) -> Dict[str, Any]:
        """Mock active scan."""
        return {
            "scan_type": "active",
            "target_url": target_url,
            "scan_id": "mock-123",
            "timestamp": datetime.utcnow().isoformat(),
            "alerts": [
                {
                    "name": "SQL Injection",
                    "risk": "High",
                    "confidence": "Medium",
                    "description": "Possible SQL injection vulnerability",
                    "solution": "Use parameterized queries"
                }
            ],
            "alert_count": 1,
            "high_risk_count": 1,
            "medium_risk_count": 0,
            "low_risk_count": 0,
            "info_count": 0
        }
    
    def generate_report(self, scan_results: Dict[str, Any], format: str = "json") -> str:
        """Generate mock report."""
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"mock_zap_scan_{scan_results['scan_type']}_{timestamp}.{format}"
        filepath = self.results_dir / filename
        
        with open(filepath, 'w') as f:
            json.dump(scan_results, f, indent=2)
            
        return str(filepath)


class TestMockZAPScanning:
    """Mock ZAP scanning tests for CI/CD environments."""
    
    @pytest.fixture
    def mock_scanner(self):
        """Mock scanner fixture."""
        return MockZAPScanner()
    
    def test_mock_passive_scan(self, mock_scanner):
        """Test mock passive scan."""
        results = mock_scanner.passive_scan("http://localhost:8000")
        
        assert results["scan_type"] == "passive"
        assert results["alert_count"] == 1
        assert results["medium_risk_count"] == 1
        
        report_path = mock_scanner.generate_report(results)
        assert Path(report_path).exists()
    
    def test_mock_active_scan(self, mock_scanner):
        """Test mock active scan."""
        results = mock_scanner.active_scan("http://localhost:8000")
        
        assert results["scan_type"] == "active"
        assert results["high_risk_count"] == 1
        
        # This would fail in real scenario with high-risk vulnerabilities
        if results["high_risk_count"] > 0:
            print("HIGH RISK VULNERABILITIES DETECTED - Review required")
    
    def test_security_baseline(self, mock_scanner):
        """Test security baseline requirements."""
        # Run both scans
        passive_results = mock_scanner.passive_scan("http://localhost:8000")
        active_results = mock_scanner.active_scan("http://localhost:8000")
        
        # Security baseline checks
        total_high_risk = (
            passive_results["high_risk_count"] + 
            active_results["high_risk_count"]
        )
        
        total_medium_risk = (
            passive_results["medium_risk_count"] + 
            active_results["medium_risk_count"]
        )
        
        # Baseline: No high-risk, maximum 5 medium-risk
        assert total_high_risk == 0, f"High-risk vulnerabilities found: {total_high_risk}"
        assert total_medium_risk <= 5, f"Too many medium-risk vulnerabilities: {total_medium_risk}"


if __name__ == "__main__":
    # Run specific test
    pytest.main([__file__, "-v"])
