"""
Dependency Vulnerability Scanner

Comprehensive dependency vulnerability scanning using multiple tools:
- Safety (Python package vulnerabilities)
- Bandit (Python code security issues)
- Semgrep (Static code analysis)
- Docker container scanning
- Infrastructure as Code scanning
"""

import os
import json
import subprocess
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
import pytest
import requests


class DependencyVulnerabilityScanner:
    """Comprehensive dependency vulnerability scanner."""
    
    def __init__(self):
        self.results_dir = Path("tests/security/reports/dependencies")
        self.results_dir.mkdir(parents=True, exist_ok=True)
        self.project_root = Path(".")
    
    def scan_python_dependencies(self) -> Dict[str, Any]:
        """Scan Python dependencies for vulnerabilities using Safety."""
        try:
            # Run safety check
            result = subprocess.run([
                "python", "-m", "safety", "check",
                "--json", "--file", "requirements.txt"
            ], capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                vulnerabilities = json.loads(result.stdout) if result.stdout.strip() else []
            else:
                # Parse safety output even with vulnerabilities found
                try:
                    vulnerabilities = json.loads(result.stdout) if result.stdout.strip() else []
                except json.JSONDecodeError:
                    vulnerabilities = self._parse_safety_text_output(result.stdout)
            
            return {
                "scanner": "safety",
                "scan_type": "python_dependencies",
                "timestamp": datetime.utcnow().isoformat(),
                "vulnerabilities": vulnerabilities,
                "vulnerability_count": len(vulnerabilities),
                "high_severity_count": len([v for v in vulnerabilities if v.get("severity", "").lower() in ["high", "critical"]]),
                "status": "clean" if len(vulnerabilities) == 0 else "vulnerabilities_found"
            }
            
        except Exception as e:
            return {
                "scanner": "safety",
                "scan_type": "python_dependencies",
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "status": "error"
            }
    
    def _parse_safety_text_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse safety text output when JSON fails."""
        vulnerabilities = []
        lines = output.split('\n')
        
        current_vuln = {}
        for line in lines:
            line = line.strip()
            if not line:
                if current_vuln:
                    vulnerabilities.append(current_vuln)
                    current_vuln = {}
                continue
                
            if line.startswith("->"):
                current_vuln["package"] = line.split("->")[1].strip()
            elif "installed:" in line.lower():
                current_vuln["installed_version"] = line.split(":")[1].strip()
            elif "affected:" in line.lower():
                current_vuln["affected_versions"] = line.split(":")[1].strip()
            elif "id:" in line.lower():
                current_vuln["id"] = line.split(":")[1].strip()
                
        if current_vuln:
            vulnerabilities.append(current_vuln)
            
        return vulnerabilities
    
    def scan_with_bandit(self) -> Dict[str, Any]:
        """Scan Python code for security issues using Bandit."""
        try:
            result = subprocess.run([
                "python", "-m", "bandit",
                "-r", "src/",
                "-f", "json",
                "-o", "/dev/stdout"
            ], capture_output=True, text=True, cwd=self.project_root)
            
            if result.stdout.strip():
                bandit_results = json.loads(result.stdout)
            else:
                bandit_results = {"results": [], "metrics": {}}
            
            issues = bandit_results.get("results", [])
            
            return {
                "scanner": "bandit",
                "scan_type": "static_code_analysis",
                "timestamp": datetime.utcnow().isoformat(),
                "issues": issues,
                "issue_count": len(issues),
                "high_severity_count": len([i for i in issues if i.get("issue_severity") == "HIGH"]),
                "medium_severity_count": len([i for i in issues if i.get("issue_severity") == "MEDIUM"]),
                "low_severity_count": len([i for i in issues if i.get("issue_severity") == "LOW"]),
                "metrics": bandit_results.get("metrics", {}),
                "status": "clean" if len(issues) == 0 else "issues_found"
            }
            
        except Exception as e:
            return {
                "scanner": "bandit",
                "scan_type": "static_code_analysis",
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "status": "error"
            }
    
    def scan_with_semgrep(self) -> Dict[str, Any]:
        """Scan code with Semgrep static analysis."""
        try:
            result = subprocess.run([
                "semgrep",
                "--config=auto",
                "--json",
                "src/"
            ], capture_output=True, text=True, cwd=self.project_root)
            
            if result.stdout.strip():
                semgrep_results = json.loads(result.stdout)
            else:
                semgrep_results = {"results": []}
            
            findings = semgrep_results.get("results", [])
            
            return {
                "scanner": "semgrep",
                "scan_type": "static_code_analysis",
                "timestamp": datetime.utcnow().isoformat(),
                "findings": findings,
                "finding_count": len(findings),
                "error_count": len([f for f in findings if f.get("extra", {}).get("severity") == "ERROR"]),
                "warning_count": len([f for f in findings if f.get("extra", {}).get("severity") == "WARNING"]),
                "info_count": len([f for f in findings if f.get("extra", {}).get("severity") == "INFO"]),
                "status": "clean" if len(findings) == 0 else "findings_detected"
            }
            
        except Exception as e:
            return {
                "scanner": "semgrep",
                "scan_type": "static_code_analysis",
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "status": "error"
            }
    
    def scan_docker_containers(self) -> Dict[str, Any]:
        """Scan Docker containers for vulnerabilities."""
        try:
            # Find Dockerfiles
            dockerfiles = list(self.project_root.glob("**/Dockerfile*"))
            
            results = {
                "scanner": "docker_scan",
                "scan_type": "container_security",
                "timestamp": datetime.utcnow().isoformat(),
                "dockerfiles": [],
                "vulnerabilities": [],
                "status": "clean"
            }
            
            for dockerfile in dockerfiles:
                # Analyze Dockerfile for security issues
                dockerfile_issues = self._analyze_dockerfile(dockerfile)
                
                results["dockerfiles"].append({
                    "path": str(dockerfile),
                    "issues": dockerfile_issues,
                    "issue_count": len(dockerfile_issues)
                })
                
                results["vulnerabilities"].extend(dockerfile_issues)
            
            results["vulnerability_count"] = len(results["vulnerabilities"])
            if results["vulnerability_count"] > 0:
                results["status"] = "vulnerabilities_found"
            
            return results
            
        except Exception as e:
            return {
                "scanner": "docker_scan",
                "scan_type": "container_security",
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "status": "error"
            }
    
    def _analyze_dockerfile(self, dockerfile_path: Path) -> List[Dict[str, Any]]:
        """Analyze Dockerfile for security issues."""
        issues = []
        
        try:
            with open(dockerfile_path, 'r') as f:
                content = f.read()
                lines = content.split('\n')
            
            for i, line in enumerate(lines, 1):
                line = line.strip().upper()
                
                # Check for common security issues
                if line.startswith('USER ROOT') or 'USER 0' in line:
                    issues.append({
                        "type": "privilege_escalation",
                        "severity": "HIGH",
                        "line": i,
                        "description": "Container running as root user",
                        "recommendation": "Use non-root user"
                    })
                
                if 'ADD HTTP' in line or 'ADD HTTPS' in line:
                    issues.append({
                        "type": "insecure_download",
                        "severity": "MEDIUM",
                        "line": i,
                        "description": "Using ADD with URL (use COPY instead)",
                        "recommendation": "Use COPY for local files, RUN wget/curl for downloads"
                    })
                
                if ':LATEST' in line:
                    issues.append({
                        "type": "unpinned_version",
                        "severity": "MEDIUM",
                        "line": i,
                        "description": "Using :latest tag (unpinned version)",
                        "recommendation": "Pin to specific version tags"
                    })
                
                if 'COPY . .' in line or 'ADD . .' in line:
                    issues.append({
                        "type": "excessive_context",
                        "severity": "LOW",
                        "line": i,
                        "description": "Copying entire context (may include secrets)",
                        "recommendation": "Copy only necessary files"
                    })
        
        except Exception as e:
            issues.append({
                "type": "analysis_error",
                "severity": "INFO",
                "description": f"Could not analyze Dockerfile: {e}"
            })
        
        return issues
    
    def scan_infrastructure_code(self) -> Dict[str, Any]:
        """Scan Infrastructure as Code for security issues."""
        try:
            # Find Terraform files
            tf_files = list(self.project_root.glob("**/*.tf"))
            
            results = {
                "scanner": "iac_scanner",
                "scan_type": "infrastructure_security",
                "timestamp": datetime.utcnow().isoformat(),
                "terraform_files": [],
                "issues": [],
                "status": "clean"
            }
            
            for tf_file in tf_files:
                tf_issues = self._analyze_terraform_file(tf_file)
                
                results["terraform_files"].append({
                    "path": str(tf_file),
                    "issues": tf_issues,
                    "issue_count": len(tf_issues)
                })
                
                results["issues"].extend(tf_issues)
            
            results["issue_count"] = len(results["issues"])
            results["high_severity_count"] = len([i for i in results["issues"] if i.get("severity") == "HIGH"])
            
            if results["issue_count"] > 0:
                results["status"] = "issues_found"
            
            return results
            
        except Exception as e:
            return {
                "scanner": "iac_scanner",
                "scan_type": "infrastructure_security",
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "status": "error"
            }
    
    def _analyze_terraform_file(self, tf_file: Path) -> List[Dict[str, Any]]:
        """Analyze Terraform file for security issues."""
        issues = []
        
        try:
            with open(tf_file, 'r') as f:
                content = f.read()
                lines = content.split('\n')
            
            for i, line in enumerate(lines, 1):
                line_lower = line.strip().lower()
                
                # Check for common security issues
                if 'cidr_blocks = ["0.0.0.0/0"]' in line_lower:
                    issues.append({
                        "type": "overly_permissive_access",
                        "severity": "HIGH",
                        "line": i,
                        "file": str(tf_file),
                        "description": "Security group allows access from all IPs",
                        "recommendation": "Restrict CIDR blocks to necessary ranges"
                    })
                
                if 'versioning' in line_lower and 'false' in line_lower:
                    issues.append({
                        "type": "s3_versioning_disabled",
                        "severity": "MEDIUM",
                        "line": i,
                        "file": str(tf_file),
                        "description": "S3 bucket versioning disabled",
                        "recommendation": "Enable S3 bucket versioning"
                    })
                
                if 'encryption' in line_lower and 'false' in line_lower:
                    issues.append({
                        "type": "encryption_disabled",
                        "severity": "HIGH",
                        "line": i,
                        "file": str(tf_file),
                        "description": "Encryption disabled",
                        "recommendation": "Enable encryption at rest"
                    })
                
                if 'public_read' in line_lower or 'public-read' in line_lower:
                    issues.append({
                        "type": "public_access",
                        "severity": "HIGH",
                        "line": i,
                        "file": str(tf_file),
                        "description": "Resource configured for public access",
                        "recommendation": "Review and restrict public access"
                    })
        
        except Exception as e:
            issues.append({
                "type": "analysis_error",
                "severity": "INFO",
                "file": str(tf_file),
                "description": f"Could not analyze Terraform file: {e}"
            })
        
        return issues
    
    def generate_comprehensive_report(self) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report."""
        report = {
            "scan_timestamp": datetime.utcnow().isoformat(),
            "scans": {},
            "summary": {
                "total_issues": 0,
                "critical_issues": 0,
                "high_severity_issues": 0,
                "medium_severity_issues": 0,
                "low_severity_issues": 0
            },
            "recommendations": []
        }
        
        # Run all scans
        scans = [
            ("python_dependencies", self.scan_python_dependencies),
            ("static_code_analysis_bandit", self.scan_with_bandit),
            ("static_code_analysis_semgrep", self.scan_with_semgrep),
            ("container_security", self.scan_docker_containers),
            ("infrastructure_security", self.scan_infrastructure_code)
        ]
        
        for scan_name, scan_func in scans:
            try:
                scan_result = scan_func()
                report["scans"][scan_name] = scan_result
                
                # Update summary
                issue_count = scan_result.get("vulnerability_count", 0) or scan_result.get("issue_count", 0) or scan_result.get("finding_count", 0)
                report["summary"]["total_issues"] += issue_count
                
                high_count = scan_result.get("high_severity_count", 0) or scan_result.get("error_count", 0)
                report["summary"]["high_severity_issues"] += high_count
                
                medium_count = scan_result.get("medium_severity_count", 0) or scan_result.get("warning_count", 0)
                report["summary"]["medium_severity_issues"] += medium_count
                
                low_count = scan_result.get("low_severity_count", 0) or scan_result.get("info_count", 0)
                report["summary"]["low_severity_issues"] += low_count
                
            except Exception as e:
                report["scans"][scan_name] = {
                    "error": str(e),
                    "status": "failed"
                }
        
        # Generate recommendations
        report["recommendations"] = self._generate_recommendations(report)
        
        # Save report
        report_path = self.results_dir / f"comprehensive_vulnerability_report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        report["report_path"] = str(report_path)
        return report
    
    def _generate_recommendations(self, report: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on scan results."""
        recommendations = []
        
        if report["summary"]["high_severity_issues"] > 0:
            recommendations.append("CRITICAL: Address all high-severity security issues immediately")
        
        if report["summary"]["total_issues"] > 10:
            recommendations.append("Consider implementing automated security scanning in CI/CD pipeline")
        
        # Scan-specific recommendations
        scans = report.get("scans", {})
        
        if scans.get("python_dependencies", {}).get("vulnerability_count", 0) > 0:
            recommendations.append("Update vulnerable Python dependencies")
        
        if scans.get("static_code_analysis_bandit", {}).get("high_severity_count", 0) > 0:
            recommendations.append("Review and fix high-severity code security issues")
        
        if scans.get("container_security", {}).get("vulnerability_count", 0) > 0:
            recommendations.append("Harden Docker containers and use security best practices")
        
        if scans.get("infrastructure_security", {}).get("high_severity_count", 0) > 0:
            recommendations.append("Review and secure infrastructure configurations")
        
        if not recommendations:
            recommendations.append("Good security posture - continue regular scanning")
        
        return recommendations


# Test Classes
class TestDependencyVulnerabilityScanning:
    """Test dependency vulnerability scanning."""
    
    @pytest.fixture
    def scanner(self):
        """Scanner fixture."""
        return DependencyVulnerabilityScanner()
    
    def test_python_dependency_scan(self, scanner):
        """Test Python dependency vulnerability scan."""
        results = scanner.scan_python_dependencies()
        
        assert results["scanner"] == "safety"
        assert results["scan_type"] == "python_dependencies"
        assert "vulnerability_count" in results
        
        # Fail if high-severity vulnerabilities found
        high_severity = results.get("high_severity_count", 0)
        if high_severity > 0:
            pytest.fail(f"High-severity vulnerabilities found in dependencies: {high_severity}")
    
    def test_bandit_code_scan(self, scanner):
        """Test Bandit static code analysis."""
        results = scanner.scan_with_bandit()
        
        assert results["scanner"] == "bandit"
        assert results["scan_type"] == "static_code_analysis"
        
        # Warn on high-severity issues
        high_severity = results.get("high_severity_count", 0)
        if high_severity > 0:
            print(f"WARNING: {high_severity} high-severity code security issues found")
    
    def test_docker_container_scan(self, scanner):
        """Test Docker container security scan."""
        results = scanner.scan_docker_containers()
        
        assert results["scanner"] == "docker_scan"
        assert results["scan_type"] == "container_security"
        
        # Check for critical container issues
        critical_issues = [
            v for v in results.get("vulnerabilities", [])
            if v.get("severity") == "HIGH"
        ]
        
        if critical_issues:
            print(f"WARNING: {len(critical_issues)} critical container security issues found")
    
    def test_infrastructure_security_scan(self, scanner):
        """Test infrastructure as code security scan."""
        results = scanner.scan_infrastructure_code()
        
        assert results["scanner"] == "iac_scanner"
        assert results["scan_type"] == "infrastructure_security"
        
        # Fail on high-severity infrastructure issues
        high_severity = results.get("high_severity_count", 0)
        if high_severity > 0:
            pytest.fail(f"High-severity infrastructure security issues found: {high_severity}")
    
    def test_comprehensive_vulnerability_report(self, scanner):
        """Test comprehensive vulnerability report generation."""
        report = scanner.generate_comprehensive_report()
        
        assert "scan_timestamp" in report
        assert "scans" in report
        assert "summary" in report
        assert "recommendations" in report
        
        # Verify report file was created
        assert Path(report["report_path"]).exists()
        
        # Security gate: fail if too many high-severity issues
        if report["summary"]["high_severity_issues"] > 5:
            pytest.fail(f"Too many high-severity issues: {report['summary']['high_severity_issues']}")
        
        # Print summary
        print(f"\n=== SECURITY SCAN SUMMARY ===")
        print(f"Total Issues: {report['summary']['total_issues']}")
        print(f"High Severity: {report['summary']['high_severity_issues']}")
        print(f"Medium Severity: {report['summary']['medium_severity_issues']}")
        print(f"Low Severity: {report['summary']['low_severity_issues']}")
        print(f"Report: {report['report_path']}")
    
    @pytest.mark.integration
    def test_security_gate_integration(self, scanner):
        """Test security gate for CI/CD integration."""
        report = scanner.generate_comprehensive_report()
        
        # Define security gates
        CRITICAL_THRESHOLD = 0  # No critical issues allowed
        HIGH_THRESHOLD = 3      # Max 3 high-severity issues
        TOTAL_THRESHOLD = 20    # Max 20 total issues
        
        critical_count = report["summary"].get("critical_issues", 0)
        high_count = report["summary"]["high_severity_issues"]
        total_count = report["summary"]["total_issues"]
        
        failures = []
        
        if critical_count > CRITICAL_THRESHOLD:
            failures.append(f"Critical issues: {critical_count} > {CRITICAL_THRESHOLD}")
        
        if high_count > HIGH_THRESHOLD:
            failures.append(f"High-severity issues: {high_count} > {HIGH_THRESHOLD}")
        
        if total_count > TOTAL_THRESHOLD:
            failures.append(f"Total issues: {total_count} > {TOTAL_THRESHOLD}")
        
        if failures:
            pytest.fail(f"Security gate failures: {'; '.join(failures)}")


if __name__ == "__main__":
    scanner = DependencyVulnerabilityScanner()
    report = scanner.generate_comprehensive_report()
    print(json.dumps(report, indent=2))
